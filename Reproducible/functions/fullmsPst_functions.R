
# ------- Functions ------ ----

# Which observed histo are generated by a latent one ?
latentObsGenerates <- function(histo, vectHists){
  index4 <- which(histo == 4)
  index5 <- which(histo == 5)
  index6 <- which(histo == 6)
  hist2 <- histo
  hist2[c(index4, index5, index6)] <- 0
  a <- integer(length(vectHists))
  if(any(hist2 > 0)){
    a[which(vectHists == deparse(hist2))] <- 1
  }
  
  if(length(index4) > 0){
    for(i in index4){
      histErr <- numeric(length(histo))
      histErr[i] <- 1
      a[which(vectHists == deparse(histErr))] <- 1
    }
  }
  if(sum(index5) > 0){
    for(i in index5){
      histErr <- numeric(length(histo))
      histErr[i] <- 2
      a[which(vectHists == deparse(histErr))] <- 1
    }
  }
  if(sum(index6) > 0){
    for(i in index6){
      histErr <- numeric(length(histo))
      histErr[i] <- 3
      a[which(vectHists == deparse(histErr))] <- 1
    }
  }
  a
}

# Matrix A (y=Ax)
getA <- function(latentObservation, observation){
  vectHists <- apply(observation, 1, deparse)
  A <- t(apply(latentObservation, 1, latentObsGenerates, 
               vectHists = vectHists))
  t(A)[-which(vectHists==deparse(numeric(S))),]
}

# Simulation of data
simulCMRStades <- function(N, S, pcapture, identification, 
                           delta, Gamma){
  
  cr <- matrix(ncol = S, nrow = N, data = 0) # Matrix of capture NbIndiv * NbSample
  
  for(i in 1:N){
    stade <- sample(1:3, 1, prob = delta)
    for(t in 1:S){
      if(runif(1) < pcapture[stade, t]) { #capture
        if (runif(1) < identification[stade])
          cr[i,t] <- stade # Adding a succesful capture to cr
        else{
          ccr <- cr
          cr <- matrix(nrow = nrow(ccr)+1, ncol = S, data = 0)
          cr[1:nrow(ccr),] <- ccr[,]
          cr[nrow(cr),t] <- stade # add one hist with unique observation
        }
      }
      stade <- sample(1:3, 1, prob = Gamma[stade,])
    }
  }
  
  return(cr)
  
}


# Counts of histories in sorted vector
getSummaryCMR <- function(dta){
  summaryDta <- as.data.frame(table(apply(dta, 1, deparse)), 
                              stringsAsFactors = F)
  summaryDta$index <- sapply(summaryDta$Var1, 
                             function(h) nimGetLatentIndex(eval(parse(text=h))))
  summaryDta <- summaryDta %>% 
    arrange(index) %>% 
    select(history=Var1, index, Freq)
  summaryDta
}

# get the x without errors that verify y = A*x
getXinit <- function(latentObservation, dtaCR, init){
  xInit <- apply(latentObservation, 1, function(x) sum(x <= 3))
  xInit[xInit != S] <- 0
  xInit[xInit > 0] <- dtaCR$Freq
  xInit[1] <- init
  xInit
}

# getXu for add er
getXu = function(y2, u, latentObservation, n, M){
  Xu <- nimNumeric(length = M)
  indexs <- which(y2 > 0)
  if(length(indexs) > 0){
    for(i in 1:length(indexs)){
      I <- indexs[i]+n
      hist <- latentObservation[I,]
      if(any(hist == u)) Xu[indexs[i]] <- 1
    }
  }
  return(Xu)
  returnType(double(1))}

# Adds error to generate different xInit
addError <- function(x, latentObservation, latentIndex, S, n, M, nM){
  
  c <- 1
  xProp <- x
  
  latentObsProp <- latentObservation
  latentIdxProp <- latentIndex
  
  nu0 <- nimNumeric(S, value = 0.0)
  nu2 <- nimNumeric(S, value = 0.0)
  
  u <- nimSample(1:3)
  
  # now assuming its better to check if there is a 0 in the 
  #   one history sampled than sample one in which we know there is one
  X0 <- xProp > 0
  # def nu0
  which_nu0 <- nimNumeric()
  which_nu0 <- which(X0)
  nu0i <- nimSample(which_nu0)
  nu0 <- latentObsProp[nu0i, ]
  idxt <- nimNumeric() ; idxt <- which(nu0 == 0)
  if(length(idxt) > 0){
    t <- nimSample(idxt)
    # def nu1 and nu2
    nu1iIdx <- which(latentIdxProp == 1+u*7^(t-1))
    if(length(nu1iIdx) > 0){
      nu1i <- nu1iIdx[1]
      nu2 <- nu0 ; nu2[t] <- u+3
      idxNu2 <- nimGetLatentIndex(nu2)
      # nu2 already exists
      if(any(latentIdxProp==idxNu2))
        nu2i <- which(latentIdxProp==idxNu2)[1]
      # nu2 needs to be added
      else {
        nu2i <- which(xProp[(n+1):nM] == 0)[1] + n # first free spot
        latentObsProp[nu2i, ] <- nu2
        latentIdxProp[nu2i] <- idxNu2
      }
      b <- numeric(nM)
      b[nu0i] <- - c
      b[nu1i] <- - c
      b[nu2i] <- + c
      xProp <- xProp + b
      
    }
  }
  
  
  if(all(xProp >= 0)) 
    return(list(x=xProp, latObs=latentObsProp, latIdx=latentIdxProp))
  else return(list(x=x, latObs=latentObservation, latIdx=latentIndex))
}



# not used  in scripts
getDtaFromX <- function(x, latentObservation, S){
  dta <- matrix(nrow = sum(x), ncol=S)
  line<- 1
  for(i in 1:length(x)){
    if(x[i]>0){
      for(j in 1:x[i]){
        dta[line,] <- latentObservation[i,]
        line <- line+1
      }
    }
  }
  dta
}


# ------- Nimble Functions ------ ----
nimSample <-  nimbleFunction(
  run = function(x = double(1)){
    l <- length(x)
    ind <- rcat(1, nimRep(1/l, l))
    nsamp <- x[ind]
    
    returnType(double(0))
    return(nsamp)
  })

# calculate index of an history
# to be stored in a vector
nimGetLatentIndex <- nimbleFunction(
  run = function(h = double(1)){
    s <- 1 
    for(t in 1:length(h)) s <- s + h[t]*7^(t-1)
    return(s)
    returnType(double(0))
  })

# Calculation of forward probabilities
# Ignoring the identification errors
forwardGen <- nimbleFunction(
  setup = function(model, nbStades){
    S <- dim(model$capture)[2]
  },
  run = function(hist=double(1), tmax=double(0)){
    hist2 <- hist[1:tmax]+1
    hist2[which(hist[1:tmax] > 3)] <- hist2[which(hist[1:tmax] > 3)] - 3
    
    alphas <- nimMatrix(nrow=nbStades, ncol = tmax, value = 0)
    for(s in 1:nbStades){
      alphas[s,1] <- model$delta[s] * model$B[hist2[1], s, 1]
    }
    for(t in 2:tmax){
      for(s in 1:nbStades){
        p <- 0
        for(r in 1:nbStades){
          p <- p + alphas[r, t-1] * model$Gamma[r, s]
        }
        alphas[s, t] <-  p * model$B[hist2[t], s, t]
      }
    }
    return(alphas)
    returnType(double(2))
  }
)

# Calculation of backward probabilities
# Ignoring the identification errors
backwardGen <- nimbleFunction(
  setup = function(model, nbStades){
    S <- dim(model$capture)[2]
    },
  run = function(hist=double(1), tmax=double(0)){
    hist2 <- hist[1:tmax]+1
    hist2[which(hist[1:tmax] > 3)] <- hist2[which(hist[1:tmax] > 3)] - 3
    
    betas <- nimMatrix(nrow=nbStades, ncol = tmax, value = 0)
    betas[,tmax] <- 1
    for(it in 0:(tmax-2)){
      t <- tmax-1-it
      for(s in 1:nbStades){
        p <- 0
        for(r in 1:nbStades){
          p <- p + model$Gamma[s, r] * model$B[hist2[t+1], r, t+1] * betas[r, t+1]
        }
        betas[s, t] <- p
      }
    }
    return(betas)
    returnType(double(2))
  }
)


